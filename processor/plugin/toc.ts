import type { CustomComponents, HastHeading, IndexableElements, RMDXModule, TocList, TocListItem } from '../../types';
import type { Root } from 'hast';
import type { MdxjsEsm } from 'mdast-util-mdxjs-esm';
import type { Transformer } from 'unified';

import { valueToEstree } from 'estree-util-value-to-estree';
import { h } from 'hastscript';

import { mdx, plain } from '../../lib';
import { hasNamedExport } from '../utils';

interface Options {
  components?: CustomComponents;
}

/*
 * A rehype plugin to generate a flat list of top-level headings or jsx flow
 * elements.
 */
export const rehypeToc = ({ components = {} }: Options): Transformer<Root, Root> => {
  return (tree: Root): void => {
    if (hasNamedExport(tree, 'toc')) return;

    const headings = tree.children.filter(
      child =>
        (child.type === 'element' && ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(child.tagName)) ||
        (child.type === 'mdxJsxFlowElement' && child.name in components),
    ) as IndexableElements[];

    tree.children.unshift({
      type: 'mdxjsEsm',
      data: {
        estree: {
          type: 'Program',
          sourceType: 'module',
          body: [
            {
              type: 'ExportNamedDeclaration',
              source: null,
              specifiers: [],
              declaration: {
                type: 'VariableDeclaration',
                kind: 'const',
                declarations: [
                  {
                    type: 'VariableDeclarator',
                    id: { type: 'Identifier', name: 'toc' },
                    init: valueToEstree(headings),
                  },
                ],
              },
            },
          ],
        },
      },
    } as MdxjsEsm);
  };
};

const MAX_DEPTH = 2;

/**
 * Get the depth of a heading element based on its tag name.
 *
 * ⚠️ Be extra defensive to non-heading elements somehow making it here. This
 * should not happen, but if it does, we avoid breaking TOC depth calculations
 * by returning `Infinity`, thus removing them from depth considerations.
 * @link https://linear.app/readme-io/issue/CX-2543/tabapay-toc-does-not-respect-headers-nesting
 *
 * @example
 * getDepth({ tagName: 'h1' }) // 1
 * getDepth({ tagName: 'h2' }) // 2
 */
const getDepth = (el: HastHeading) => {
  if (!el.tagName) return Infinity;
  return parseInt(el.tagName?.match(/^h(\d)/)[1], 10);
};

/*
 * `tocToHast` consumes the list generated by `rehypeToc` and produces a hast
 * of nested lists to be rendered as a table of contents.
 */
const tocToHast = (headings: HastHeading[] = []): TocList => {
  const headingDepths = headings.map(getDepth);
  const min = Math.min(...headingDepths);
  const ast = h('ul') as TocList;
  const stack: TocList[] = [ast];

  headings.forEach(heading => {
    const depth = getDepth(heading) - min + 1;
    if (depth > MAX_DEPTH) return;

    while (stack.length < depth) {
      const ul = h('ul') as TocList;

      stack[stack.length - 1].children.push(h('li', null, ul) as TocListItem);
      stack.push(ul);
    }

    while (stack.length > depth) {
      stack.pop();
    }

    if (heading.properties) {
      const content = plain({ type: 'root', children: heading.children }) as string;

      stack[stack.length - 1].children.push(
        h('li', null, h('a', { href: `#${heading.properties.id}` }, content)) as TocListItem,
      );
    }
  });

  return ast;
};

/*
 * `tocHastToMdx` is a utility for combining `TocList`s of a root document and
 * any child components it may have. Once combined it will generate a markdown
 * doc representing a table of contents.
 */
export const tocHastToMdx = (toc: IndexableElements[] | undefined, components: Record<string, RMDXModule['toc']>) => {
  if (typeof toc === 'undefined') return '';

  const injected = toc.flatMap(node => {
    if (node.type === 'mdxJsxFlowElement') {
      return components[node.name] || [];
    }
    return node;
  });

  const tocHast = tocToHast(injected as HastHeading[]);
  return mdx({ type: 'root', children: [tocHast] }, { hast: true });
};
